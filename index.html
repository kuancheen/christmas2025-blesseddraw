<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Blessed Jackpot Draw</title>

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>

    <!-- Babel -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>

    <!-- Canvas Confetti -->
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.5.1/dist/confetti.browser.min.js"></script>

    <!-- Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700&family=Kaushan+Script&display=swap"
        rel="stylesheet">

    <style>
        body {
            background-color: #1a3ba0;
            /* Royal Blue fallback */
            background: radial-gradient(circle at 50% 30%, #2547c0 0%, #1a3ba0 40%, #0a1850 100%);
            color: white;
            font-family: 'Poppins', sans-serif;
            min-height: 100vh;
        }

        /* Digit Card Styling */
        .digit-card {
            background: linear-gradient(to bottom, #1e3a8a 50%, #172554 50%);
            /* Blue-ish slate */
            border-radius: 8px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.5);
            position: relative;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .digit-card::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 0;
            right: 0;
            height: 1px;
            background: rgba(0, 0, 0, 0.6);
            box-shadow: 0 1px 0 rgba(255, 255, 255, 0.1);
        }

        .glass-panel {
            background: rgba(15, 23, 42, 0.6);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.15);
        }

        .gold-text {
            color: #fbbf24;
            /* Fallback */
            background: linear-gradient(to bottom, #fef3c7 0%, #fbbf24 40%, #d97706 100%);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0px 2px 4px rgba(0, 0, 0, 0.3);
        }

        .gold-border {
            border: 2px solid #fbbf24;
            box-shadow: 0 0 15px rgba(251, 191, 36, 0.4);
        }

        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(15, 23, 42, 0.5);
        }

        ::-webkit-scrollbar-thumb {
            background: #475569;
            border-radius: 4px;
        }

        /* Custom Font Classes */
        .font-script {
            font-family: 'Kaushan Script', cursive;
        }
    </style>
</head>

<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // --- Helper Function for Initial Data Generation ---
        const generateInitialPool = (count = 200) => {
            const pool = [];
            const max = 2000;
            const seen = new Set();

            // Generate unique random numbers (0000 to 2000)
            while (pool.length < count && seen.size <= max) {
                // Generate random number from 0 to 2000
                const randomNum = Math.floor(Math.random() * (max + 1));
                const val = randomNum.toString().padStart(4, '0');

                if (!seen.has(val)) {
                    seen.add(val);
                    pool.push({ val: val, drawn: false });
                }
            }

            return pool;
        };

        const getInitialBoxes = (count) => {
            const boxes = [];
            for (let i = 0; i < count; i++) {
                // ADDED: claimed state to differentiate manual claiming from auto-disabling/skipping
                boxes.push({ id: i, label: `Prize ${i + 1}`, active: true, currentNumber: "0000", claimed: false });
            }
            return boxes;
        };

        const safeParse = (key, defaultValue) => {
            const saved = localStorage.getItem(key);
            try {
                return saved ? JSON.parse(saved) : defaultValue;
            } catch {
                return defaultValue;
            }
        }
        // --- End Helper Function ---

        // --- Components ---

        // Lucide Icon Wrapper
        const LucideIcon = ({ name, className }) => {
            const ref = useRef(null);
            useEffect(() => {
                if (ref.current) {
                    const i = document.createElement('i');
                    i.setAttribute('data-lucide', name);
                    ref.current.innerHTML = '';
                    ref.current.appendChild(i);
                    lucide.createIcons({
                        root: ref.current,
                        nameAttr: 'data-lucide',
                        attrs: { class: `lucide lucide-${name} ${className || ''}` }
                    });
                }
            }, [name, className]);
            return <span ref={ref} className="inline-flex items-center justify-center" />;
        };

        // Single Digit Flip Card (With Cycling Animation)
        const FlipDigit = ({ target, isLocked, isSpinning, isClaimed, isActive }) => {
            const [displayVal, setDisplayVal] = useState("0");

            useEffect(() => {
                if (!isSpinning) {
                    setDisplayVal(target);
                    return;
                }
                if (isLocked) {
                    setDisplayVal(target);
                    return;
                }
                const interval = setInterval(() => {
                    setDisplayVal(Math.floor(Math.random() * 10).toString());
                }, 60);
                return () => clearInterval(interval);
            }, [isLocked, isSpinning, target]);

            // Determine text color based on state
            let textColorClass = 'text-white';
            let bgColorClass = 'bg-slate-800';

            if (isClaimed) {
                textColorClass = 'text-red-300 opacity-80';
                bgColorClass = 'bg-red-900/40';
            } else if (!isActive) { // If not active (and not claimed), it's disabled/skipped
                textColorClass = 'text-slate-400 opacity-80';
                bgColorClass = 'bg-slate-900/40'; // A darker gray for disabled numbers
            } else if (!isLocked && isSpinning) {
                textColorClass = 'blur-[1px] text-blue-200';
            }

            return (
                <div className={`w-10 h-16 sm:w-12 sm:h-20 md:w-14 md:h-20 rounded-lg digit-card flex items-center justify-center relative ${bgColorClass}`}>
                    <span className={`text-3xl sm:text-4xl md:text-5xl font-mono font-bold ${textColorClass}`}>
                        {displayVal}
                    </span>
                </div>
            );
        };

        // A Group of 4 Digits (One Jackpot Box)
        const NumberBox = ({ number, isActive, label, revealedCount, isDrawing, setRef, isClaimed }) => {
            const safeNumber = (number !== undefined && number !== null) ? number : "0000";
            const paddedNumber = safeNumber.toString().padStart(4, '0');
            const targetDigits = paddedNumber.split('');

            const digitsAreSpinning = isDrawing && isActive && revealedCount < 4;
            const isFullyDrawn = isActive && revealedCount === 4 && safeNumber !== "0000";
            const finalRevealedCount = isActive ? (isDrawing ? (revealedCount || 0) : 4) : 4;

            // Determine label and styling based on isActive AND isClaimed
            let boxBorderClass = 'gold-border';
            let labelTextColorClass = 'text-amber-500';
            let statusLabel = '';
            let statusTextColorClass = 'text-red-600'; // Default for claimed/disabled status text

            if (!isActive) { // If box is not active
                if (isClaimed) { // It's specifically claimed (manual toggle after draw)
                    boxBorderClass = 'border-red-600 shadow-xl shadow-red-900/30';
                    labelTextColorClass = 'text-red-400';
                    statusLabel = 'CLAIMED';
                    statusTextColorClass = 'text-red-500'; // Red status text for claimed
                } else { // It's disabled/skipped (not active, not claimed)
                    boxBorderClass = 'border-slate-600 shadow-xl shadow-slate-900/30'; // Gray border
                    labelTextColorClass = 'text-slate-500'; // Gray label text
                    statusLabel = 'DISABLED';
                    statusTextColorClass = 'text-slate-500'; // Gray status text for disabled
                }
            } else if (isFullyDrawn) {
                // Active and Drawn (Unclaimed Winner)
                boxBorderClass = 'border-green-500 shadow-xl shadow-green-500/20';
            }


            return (
                <div className={`flex flex-col items-center p-4 rounded-xl transition-all duration-500 ${isActive
                    ? 'bg-blue-950/40 backdrop-blur-sm scale-100 opacity-100' // Active state
                    : 'bg-slate-900/30 scale-95 opacity-80' // Inactive state
                    } ${boxBorderClass}`}> {/* Apply dynamic border class */}

                    <div className="mb-3 font-bold tracking-widest uppercase text-xs sm:text-sm">
                        <span className={labelTextColorClass}>{label}</span>
                        {!isActive && <span className={`ml-2 font-bold ${statusTextColorClass}`}>({statusLabel})</span>}
                    </div>

                    {/* FIXED: Using gap-1 to ensure digits are contained within the black box */}
                    <div className="flex justify-center gap-1 bg-black p-2 rounded-lg shadow-inner border border-slate-700">
                        {targetDigits.map((d, i) => (
                            <FlipDigit
                                key={i}
                                target={d}
                                isSpinning={digitsAreSpinning}
                                isLocked={i < finalRevealedCount}
                                isClaimed={isClaimed}
                                isActive={isActive}
                            />
                        ))}
                    </div>

                    <div className="mt-3 h-8 flex items-center gap-2">
                        {isFullyDrawn && (
                            <span ref={setRef} className="text-xs font-bold text-green-400 bg-green-400/10 px-2 py-1 rounded-full border border-green-400/20">
                                DRAWN
                            </span>
                        )}
                    </div>
                </div>
            );
        };

        // History Log Component
        const HistoryLog = ({ drawHistory, toggleBox, boxes, isDrawing }) => {
            // UPDATED: Format time to include date in YYYY-MM-DD format
            const formatTime = (timestamp) => {
                const date = new Date(timestamp);

                // Date components
                const y = date.getFullYear();
                const mo = (date.getMonth() + 1).toString().padStart(2, '0'); // Months are 0-indexed
                const d = date.getDate().toString().padStart(2, '0');

                // Time components
                const h = date.getHours().toString().padStart(2, '0');
                const m = date.getMinutes().toString().padStart(2, '0');
                const s = date.getSeconds().toString().padStart(2, '0');
                const ms = date.getMilliseconds().toString().padStart(3, '0');

                // Format: YYYY-MM-DD HH:MM:SS.mmm
                return `${y}-${mo}-${d} ${h}:${m}:${s}.${ms}`;
            };

            return (
                <div className="bg-blue-950/40 border border-blue-900/50 rounded-xl p-4 w-full h-80 flex flex-col shadow-inner backdrop-blur-sm">
                    <h3 className="text-sm text-slate-400 uppercase tracking-wider mb-3 font-sans flex items-center gap-2">
                        <LucideIcon name="clipboard-list" className="w-4 h-4 text-sky-400" />
                        Draw History
                    </h3>
                    <div className="flex-1 overflow-y-auto space-y-2">
                        {drawHistory.length === 0 ? (
                            <p className="text-center text-slate-500 p-4">No draws have been recorded yet.</p>
                        ) : (
                            drawHistory.slice().reverse().map((entry, index) => {
                                // Find the prize box associated with this history entry
                                const box = boxes.find(b => b.label === entry.prizeLabel);
                                const boxId = box ? box.id : null;

                                // FIX: Use the box's canonical claimed status for rendering consistency.
                                // If the box is not found (e.g., deleted), fall back to the history entry's internal status.
                                const isPrizeClaimed = box ? box.claimed : entry.claimed;

                                // Determine status and classes based on the canonical box state (isPrizeClaimed)
                                let statusText = isPrizeClaimed ? "Claimed" : "Unclaimed";
                                let statusColor = isPrizeClaimed ? "text-red-400" : "text-green-400";
                                let buttonClass = isPrizeClaimed ? "bg-red-600/20 text-red-300 hover:bg-red-600/40" : "bg-green-600/20 text-green-300 hover:bg-green-600/40";
                                let buttonIcon = isPrizeClaimed ? "wallet-x" : "gift";

                                return (
                                    <div key={`${entry.timestamp}-${entry.prizeLabel}-${index}`} className="flex justify-between items-center bg-slate-800/70 p-3 rounded-lg border border-slate-700/50 transition-all hover:bg-slate-800">
                                        <div className="flex flex-col text-sm">
                                            <span className="font-mono text-lg text-amber-300">{entry.number}</span>
                                            {/* Display the new full timestamp format */}
                                            <span className="text-slate-400 text-xs font-mono">{entry.prizeLabel} at {formatTime(entry.timestamp)}</span>
                                        </div>
                                        <div className="flex items-center gap-3">
                                            {/* Display status based on the canonical box state */}
                                            <span className={`text-xs font-bold ${statusColor}`}>{statusText}</span>
                                            {boxId !== null && (
                                                <button
                                                    // Action remains toggleBox(boxId)
                                                    onClick={() => toggleBox(boxId)}
                                                    disabled={isDrawing}
                                                    className={`flex items-center gap-1 px-2 py-1 text-xs rounded-full font-semibold transition-colors ${buttonClass}`}
                                                    title={isPrizeClaimed ? "Mark as Unclaimed (Re-activate Prize)" : "Mark as Claimed (Disable Prize)"}
                                                >
                                                    <LucideIcon name={buttonIcon} className="w-3 h-3" />
                                                    {isPrizeClaimed ? 'Unclaim' : 'Claim'}
                                                </button>
                                            )}
                                        </div>
                                    </div>
                                );
                            })
                        )}
                    </div>
                </div>
            );
        };

        const SettingsModal = ({ isOpen, onClose, numberPool, setNumberPool, resetData, prizeCount, setPrizeCount, boxes }) => {
            const [textInput, setTextInput] = useState("");
            // Initializing with the prizeCount state, allowing it to be potentially null/empty string for editing
            const [localPrizeCount, setLocalPrizeCount] = useState(prizeCount === 0 ? '' : prizeCount);
            const [confirmingReset, setConfirmingReset] = useState(false);

            useEffect(() => {
                const text = numberPool.map(n => `${n.val}`).join('\n');
                setTextInput(text);
                setLocalPrizeCount(prizeCount === 0 ? '' : prizeCount);
                if (isOpen) setConfirmingReset(false);
            }, [isOpen, prizeCount]);

            const handleSave = () => {
                // 1. Update Number Pool
                const lines = textInput.split('\n').map(s => s.trim()).filter(s => s !== "");
                const newPool = lines.map(val => {
                    const existing = numberPool.find(n => n.val === val);
                    const paddedVal = val.padStart(4, '0');
                    return { val: paddedVal, drawn: existing ? existing.drawn : false };
                });
                setNumberPool(newPool);

                // 2. Update Prize Count - Validate before saving
                let finalCount;

                // If localPrizeCount is empty string, treat it as 1 for saving
                if (localPrizeCount === '' || isNaN(localPrizeCount)) {
                    finalCount = 1;
                } else {
                    finalCount = parseInt(localPrizeCount, 10);
                    // Clamp to the 1-10 range
                    if (finalCount > 10) finalCount = 10;
                    if (finalCount < 1) finalCount = 1;
                }

                setPrizeCount(finalCount);

                onClose();
            };

            const handlePrizeCountChange = (e) => {
                const value = e.target.value;
                // Allow empty string or numbers only
                if (value === '') {
                    setLocalPrizeCount('');
                    return;
                }

                const count = parseInt(value, 10);
                if (!isNaN(count)) {
                    // Set the raw number, we will clamp it during the final save
                    setLocalPrizeCount(count);
                }
            };

            const handleResetClick = () => {
                if (confirmingReset) {
                    resetData();
                    onClose();
                } else {
                    setConfirmingReset(true);
                }
            };

            const handleClose = () => {
                setConfirmingReset(false);
                onClose();
            }

            if (!isOpen) return null;

            return (
                <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/80 backdrop-blur-sm p-4">
                    <div className="bg-slate-900 border border-slate-700 rounded-2xl w-full max-w-2xl flex flex-col max-h-[90vh] shadow-2xl shadow-blue-900/20">
                        <div className="p-6 border-b border-slate-800 flex justify-between items-center">
                            <h2 className="text-2xl text-amber-500 font-bold">Data Management</h2>
                            <button onClick={handleClose} className="text-slate-400 hover:text-white">
                                <LucideIcon name="x" />
                            </button>
                        </div>

                        <div className="p-6 overflow-y-auto flex-1 space-y-6">

                            {/* PRIZE COUNT SETTING */}
                            <div className="bg-slate-800/50 border border-slate-700 p-4 rounded-lg">
                                <label className="block text-slate-400 text-sm mb-2 flex items-center gap-2">
                                    <LucideIcon name="gift" className="w-4 h-4 text-amber-400" />
                                    Number of Prizes (1-10)
                                </label>
                                <input
                                    type="number"
                                    min="1"
                                    max="10"
                                    // Use localPrizeCount, which can be an empty string
                                    value={localPrizeCount}
                                    onChange={handlePrizeCountChange}
                                    className="w-full bg-slate-950 border border-slate-700 rounded-lg p-3 text-white font-mono text-lg focus:outline-none focus:border-amber-500 transition-colors"
                                />
                                <p className="text-xs text-slate-500 mt-1">Current Boxes: {boxes.length}. Set between 1 and 10.</p>
                            </div>

                            {/* NUMBER POOL SETTING */}
                            <div className="bg-blue-900/20 border border-blue-500/30 p-4 rounded-lg text-blue-200 text-sm">
                                <p><strong>Instruction:</strong> Paste your numbers below (one per line). All drawn statuses will be retained unless you click "Reset Draw History".</p>
                            </div>

                            <div>
                                <label className="block text-slate-400 text-sm mb-2">Number List (Current Size: {numberPool.length})</label>
                                <textarea
                                    className="w-full h-48 bg-slate-950 border border-slate-700 rounded-lg p-4 text-white font-mono focus:outline-none focus:border-amber-500 transition-colors"
                                    value={textInput}
                                    onChange={(e) => setTextInput(e.target.value)}
                                    placeholder="1234&#10;5678..."
                                ></textarea>
                            </div>

                            <div className="flex justify-between items-center border-t border-slate-800 pt-4">
                                <div className="flex items-center gap-4">
                                    <button
                                        onClick={handleResetClick}
                                        className={`text-sm hover:text-red-300 underline transition-colors ${confirmingReset
                                            ? 'text-red-300 font-bold border-2 border-red-500/50 px-2 py-1 rounded-md bg-red-900/20'
                                            : 'text-red-400'
                                            }`}
                                    >
                                        {confirmingReset ? "Click AGAIN to CONFIRM RESET" : "Reset Draw History"}
                                    </button>
                                    {confirmingReset && (
                                        <span className="text-red-400 text-xs">Warning: This action is permanent!</span>
                                    )}
                                </div>

                                <div className="text-right text-slate-500 text-xs">
                                    Total Loaded: {textInput.split('\n').filter(t => t.trim()).length}
                                </div>
                            </div>
                        </div>

                        <div className="p-6 border-t border-slate-800 flex justify-end gap-3">
                            <button onClick={handleClose} className="px-4 py-2 text-slate-300 hover:text-white">Cancel</button>
                            <button onClick={handleSave} className="px-6 py-2 bg-amber-600 hover:bg-amber-500 text-white font-bold rounded-lg shadow-lg shadow-amber-600/20 transition-all">
                                Save Changes
                            </button>
                        </div>
                    </div>
                </div>
            );
        };


        // --- Main App ---
        const App = () => {
            // -- State --
            const [isDrawing, setIsDrawing] = useState(false);
            const [showSettings, setShowSettings] = useState(false);

            // Prize Count State
            const [prizeCount, setPrizeCount] = useState(() => safeParse('blessed_prize_count', 5));

            // Draw History State: { number: string, prizeLabel: string, claimed: boolean, timestamp: number }[]
            const [drawHistory, setDrawHistory] = useState(() => safeParse('blessed_draw_history', []));

            // Ref to store the DOM element for the 'Drawn' status of each box
            const numberBoxRefs = useRef({});

            const [numberPool, setNumberPool] = useState(() => {
                const saved = localStorage.getItem('blessed_pool');
                return saved ? safeParse('blessed_pool', generateInitialPool()) : generateInitialPool();
            });

            const [boxes, setBoxes] = useState(() => {
                const savedBoxes = safeParse('blessed_boxes', null);
                return savedBoxes || getInitialBoxes(prizeCount);
            });

            const [revealCounts, setRevealCounts] = useState({});

            // -- Effects --
            useEffect(() => { localStorage.setItem('blessed_pool', JSON.stringify(numberPool)); }, [numberPool]);
            useEffect(() => { localStorage.setItem('blessed_boxes', JSON.stringify(boxes)); }, [boxes]);
            useEffect(() => { localStorage.setItem('blessed_prize_count', prizeCount.toString()); }, [prizeCount]);
            useEffect(() => { localStorage.setItem('blessed_draw_history', JSON.stringify(drawHistory)); }, [drawHistory]);


            // EFFECT to manage box count when prizeCount changes
            useEffect(() => {
                const newBoxes = [];
                const existingBoxesMap = new Map(boxes.map(box => [box.id, box]));

                for (let i = 0; i < prizeCount; i++) {
                    const existingBox = existingBoxesMap.get(i);
                    if (existingBox) {
                        // Preserve existing box data (active status, number, claimed status, etc.)
                        newBoxes.push(existingBox);
                    } else {
                        // Create new box
                        newBoxes.push({ id: i, label: `Prize ${i + 1}`, active: true, currentNumber: "0000", claimed: false });
                    }
                }

                // If the array size changed, update the state
                if (newBoxes.length !== boxes.length) {
                    setBoxes(newBoxes);
                }
            }, [prizeCount]);

            // -- Handlers --
            const toggleBox = (id) => {
                const toggledBox = boxes.find(b => b.id === id);
                if (!toggledBox) return;

                const newActiveState = !toggledBox.active;

                // If a number has been drawn, toggling active state implies toggling the claimed state.
                const isDrawn = toggledBox.currentNumber !== "0000";

                let newClaimedState = toggledBox.claimed; // Default to current state

                if (isDrawn) {
                    // If toggling from Active(True) to Inactive(False) AND drawn -> Mark as CLAIMED (claimed: true)
                    if (!newActiveState) {
                        newClaimedState = true;
                        // If toggling from Inactive(False) to Active(True) AND drawn -> Mark as UNCLAIMED (claimed: false)
                    } else if (newActiveState) {
                        newClaimedState = false;
                    }
                }

                // Update the box state
                const newBoxes = boxes.map(b => b.id === id ? { ...b, active: newActiveState, claimed: newClaimedState } : b);
                setBoxes(newBoxes);

                // Update history if a number was drawn
                if (isDrawn) {
                    setDrawHistory(prevHistory => {
                        // Find the most recent draw entry for this number (which is the one currently in the box)
                        const historyIndex = prevHistory.map(item => item.number).lastIndexOf(toggledBox.currentNumber);

                        if (historyIndex !== -1) {
                            const newHistory = [...prevHistory];
                            // Update the claimed status of the history entry (This is for the record, 
                            // but the UI now relies on the box.claimed state for consistency)
                            newHistory[historyIndex] = { ...newHistory[historyIndex], claimed: newClaimedState };
                            return newHistory;
                        }
                        return prevHistory;
                    });
                }
            };

            const resetData = () => {
                setNumberPool(prev => prev.map(n => ({ ...n, drawn: false })));
                // Reset active and claimed state on full reset
                setBoxes(prev => prev.map((b, i) => ({ ...b, currentNumber: "0000", active: true, claimed: false, id: i, label: `Prize ${i + 1}` })));
                setRevealCounts({});
                setPrizeCount(5);
                setDrawHistory([]); // Clear the history on full reset
            };

            const handleDraw = () => {
                const availableNumbers = numberPool.filter(n => !n.drawn);
                const activeBoxes = boxes.filter(b => b.active);

                // --- Determine the actual number of prizes to draw ---
                const drawCount = Math.min(activeBoxes.length, availableNumbers.length);

                if (drawCount === 0) {
                    console.error("Draw cancelled: No numbers available or no boxes active for this draw.");
                    return;
                }

                // 1. Identify the boxes that WILL be drawn this round 
                const boxesToDraw = activeBoxes.slice(0, drawCount);

                // 2. Identify the boxes that are active but will be skipped/disabled due to lack of numbers
                const boxesToSkip = activeBoxes.slice(drawCount);
                // --- END LOGIC ---

                setIsDrawing(true);

                const initialCounts = {};
                boxesToDraw.forEach(b => initialCounts[b.id] = 0);
                setRevealCounts(initialCounts);

                const shuffled = [...availableNumbers].sort(() => 0.5 - Math.random());
                const winners = shuffled.slice(0, drawCount);

                const newBoxes = [...boxes];
                const newPool = [...numberPool];
                const winnersMap = new Map();

                // 1. Process Boxes To Draw (Winners)
                boxesToDraw.forEach((box, idx) => {
                    const winningNumber = winners[idx].val;

                    // A. Update Boxes (Set number, keep active: true, keep claimed: false)
                    newBoxes[box.id] = { ...newBoxes[box.id], currentNumber: winningNumber };

                    // B. Update Pool (Mark as drawn)
                    const pIdx = newPool.findIndex(n => n.val === winningNumber);
                    if (pIdx !== -1) newPool[pIdx].drawn = true;

                    // C. Store winner info for delayed History update (TIMESTAMP REMOVED HERE)
                    winnersMap.set(box.id, {
                        number: winningNumber,
                        prizeLabel: box.label,
                        claimed: false, // Initially unclaimed
                        // Timestamp will be added when written to history
                    });
                });

                // 2. Process Boxes To Skip (Auto-Disable)
                boxesToSkip.forEach(box => {
                    // Auto-disable prize: set active: false, and explicitly set claimed: false
                    // It's disabled, but not claimed.
                    newBoxes[box.id] = { ...newBoxes[box.id], active: false, claimed: false };
                });

                setBoxes(newBoxes);
                setNumberPool(newPool);

                let globalDelay = 500;
                let completedBoxes = 0;

                // Animation loop only runs for boxes that received a number
                boxesToDraw.forEach((box, boxIdx) => {
                    for (let digit = 1; digit <= 4; digit++) {
                        const digitDelay = globalDelay + (digit * 400);

                        setTimeout(() => {
                            setRevealCounts(prev => ({
                                ...prev,
                                [box.id]: digit
                            }));

                            if (digit === 4) {

                                // --- HISTORY UPDATE GOES HERE (AFTER FINAL DIGIT LANDS) ---
                                const historyEntry = winnersMap.get(box.id);
                                if (historyEntry) {
                                    // FIXED: Create history entry with a FRESH timestamp
                                    const timedHistoryEntry = { ...historyEntry, timestamp: Date.now() };
                                    setDrawHistory(prev => [...prev, timedHistoryEntry]);
                                }
                                // --- END HISTORY UPDATE ---

                                setTimeout(() => {
                                    const fireConfetti = typeof window.confetti === 'function' ? window.confetti : null;

                                    if (fireConfetti) {
                                        setTimeout(() => {
                                            const boxElement = numberBoxRefs.current[box.id];
                                            if (boxElement) {
                                                const rect = boxElement.getBoundingClientRect();
                                                const x = rect.left + rect.width / 2;
                                                const y = rect.top + rect.height / 2;

                                                fireConfetti({
                                                    particleCount: 150,
                                                    spread: 60,
                                                    angle: 90,
                                                    origin: {
                                                        x: x / window.innerWidth,
                                                        y: y / window.innerHeight
                                                    },
                                                    colors: ['#fcd34d', '#d97706', '#10b981', '#ffffff']
                                                });
                                            }
                                        }, 50);
                                    }

                                    completedBoxes++;

                                    if (completedBoxes === boxesToDraw.length) {
                                        setIsDrawing(false);
                                    }

                                }, 500);
                            }
                        }, digitDelay);
                    }
                    globalDelay += 2000;
                });
            };

            // Calculate responsive grid columns based on prize count
            let gridLayoutClass = "grid-cols-1";
            if (prizeCount === 2) gridLayoutClass = "md:grid-cols-2";
            else if (prizeCount === 3) gridLayoutClass = "md:grid-cols-3";
            else if (prizeCount === 4) gridLayoutClass = "md:grid-cols-4";
            else if (prizeCount === 5) gridLayoutClass = "md:grid-cols-3 xl:grid-cols-5";
            else if (prizeCount >= 6 && prizeCount <= 8) gridLayoutClass = "md:grid-cols-4 lg:grid-cols-4 xl:grid-cols-4";
            else if (prizeCount >= 9) gridLayoutClass = "md:grid-cols-5 lg:grid-cols-5 xl:grid-cols-5";

            // --- UI Helper variables for Draw Button State ---
            const availableNumbersCount = numberPool.filter(n => !n.drawn).length;
            const activeBoxesCount = boxes.filter(b => b.active).length;
            const hasActiveBoxes = activeBoxesCount > 0;
            const hasAvailableNumbers = availableNumbersCount > 0;
            const canDraw = hasActiveBoxes && hasAvailableNumbers;

            let drawButtonText = "Start Draw";
            let drawButtonIcon = "dice-5";
            let drawButtonClasses = "bg-gradient-to-r from-amber-600 to-amber-700 hover:from-amber-500 hover:to-amber-600 text-white shadow-lg shadow-amber-600/30 transform hover:scale-[1.02] active:scale-[0.98] border border-amber-500/50";

            if (isDrawing) {
                drawButtonText = "Drawing...";
                drawButtonIcon = "loader-2";
                drawButtonClasses = "bg-green-700 disabled:opacity-50 disabled:cursor-not-allowed";
            } else if (!hasAvailableNumbers) {
                drawButtonText = "No Numbers Left";
                drawButtonIcon = "alert-triangle";
                drawButtonClasses = "bg-red-700 disabled:opacity-50 disabled:cursor-not-allowed";
            } else if (!hasActiveBoxes) {
                drawButtonText = "No Active Prizes";
                drawButtonIcon = "gift";
                drawButtonClasses = "bg-orange-700 disabled:opacity-50 disabled:cursor-not-allowed";
            }


            // -- Render --
            return (
                <div className="min-h-screen flex flex-col items-center justify-center p-4 relative overflow-x-hidden">

                    {/* Background elements removed to let body background show through */}
                    <div className="absolute top-0 left-0 w-full h-full bg-[url('https://www.transparenttextures.com/patterns/stardust.png')] opacity-20 pointer-events-none mix-blend-overlay"></div>
                    <div className="absolute top-0 left-0 w-full h-32 bg-gradient-to-b from-blue-500/10 to-transparent -z-10"></div>

                    <div className="text-center mb-10 relative z-10">
                        <div className="flex flex-col items-center justify-center gap-2 mb-2">
                            <h1 className="text-6xl md:text-8xl gold-text font-script tracking-wide transform -rotate-2">Blessed Draw</h1>
                            <div className="h-1 w-32 bg-gradient-to-r from-transparent via-amber-500 to-transparent opacity-50"></div>
                        </div>
                        <p className="text-blue-200 tracking-[0.3em] text-sm font-semibold uppercase mt-2">Where Wisdom Finds Peace</p>
                    </div>

                    <div className={`grid ${gridLayoutClass} gap-4 md:gap-6 w-full max-w-7xl mb-12`}>
                        {boxes.map((box) => (
                            <NumberBox
                                key={box.id}
                                id={box.id}
                                label={box.label}
                                number={box.currentNumber}
                                isActive={box.active}
                                isClaimed={box.claimed}
                                isDrawing={isDrawing}
                                revealedCount={revealCounts[box.id]}
                                setRef={(el) => (numberBoxRefs.current[box.id] = el)}
                            />
                        ))}
                    </div>

                    <div className="glass-panel rounded-2xl p-6 w-full max-w-4xl shadow-2xl">
                        <div className="flex flex-col md:flex-row justify-between items-center gap-6">

                            <div className="flex-1 w-full">
                                <h3 className="text-xs text-slate-400 uppercase tracking-wider mb-3 font-sans">Active Prizes</h3>
                                <div className="flex flex-wrap gap-2 h-20 overflow-y-auto pr-2">
                                    {boxes.map(box => {
                                        let buttonClasses;
                                        if (box.active) {
                                            buttonClasses = 'bg-amber-600/20 border-amber-600 text-amber-500 hover:bg-amber-600/30'; // Active (Gold)
                                        } else if (box.claimed) {
                                            buttonClasses = 'bg-red-900/30 border-red-600 text-red-500 hover:bg-red-900/40'; // Claimed (Red)
                                        } else {
                                            buttonClasses = 'bg-slate-800/30 border-slate-600 text-slate-500 hover:bg-slate-800/50'; // Disabled (Gray)
                                        }

                                        return (
                                            <button
                                                key={box.id}
                                                onClick={() => !isDrawing && toggleBox(box.id)}
                                                disabled={isDrawing}
                                                className={`px-3 py-1.5 rounded text-xs font-bold transition-all border ${buttonClasses}`}
                                            >
                                                {box.label} ({box.active ? 'Active' : box.claimed ? 'Claimed' : 'Disabled'})
                                            </button>
                                        );
                                    })}
                                </div>
                            </div>

                            <div className="w-full md:w-auto flex flex-col items-center">

                                <div className="flex gap-4 w-full justify-center">
                                    <button
                                        onClick={() => setShowSettings(true)}
                                        disabled={isDrawing}
                                        className="px-6 py-3 bg-slate-700 hover:bg-slate-600 text-white font-bold rounded-xl flex items-center gap-2 transition-all shadow-md shadow-slate-900/50 disabled:opacity-50 disabled:cursor-not-allowed"
                                    >
                                        <LucideIcon name="settings" className="w-5 h-5" />
                                        Settings
                                    </button>

                                    <button
                                        onClick={handleDraw}
                                        disabled={isDrawing || !canDraw}
                                        className={`px-8 py-3 text-white font-bold text-lg rounded-xl flex items-center gap-2 transition-all ${drawButtonClasses}`}
                                    >
                                        <LucideIcon name={drawButtonIcon} className="w-6 h-6" />
                                        {drawButtonText}
                                    </button>
                                </div>
                                <p className="text-slate-500 text-xs mt-2">Available Numbers: {availableNumbersCount}</p>
                            </div>
                        </div>
                    </div>

                    <div className="w-full max-w-4xl mt-6">
                        <HistoryLog
                            drawHistory={drawHistory}
                            toggleBox={toggleBox}
                            boxes={boxes}
                            isDrawing={isDrawing}
                        />
                    </div>

                    <SettingsModal
                        isOpen={showSettings}
                        onClose={() => setShowSettings(false)}
                        numberPool={numberPool}
                        setNumberPool={setNumberPool}
                        resetData={resetData}
                        prizeCount={prizeCount}
                        setPrizeCount={setPrizeCount}
                        boxes={boxes}
                    />

                    {/* Updated: Version Counter */}
                    <div className="fixed bottom-3 right-4 text-xs text-slate-600 font-mono tracking-wider">
                        App Version: v1.5.0
                    </div>

                </div>
            );
        };

        // Render the App
        ReactDOM.createRoot(document.getElementById('root')).render(<App />);
    </script>
</body>

</html>